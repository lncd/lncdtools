#!/usr/bin/env bash
set -euo pipefail
#
# 20260226WF - init
# 
# TODO: add 'verb' or 'warn' instead of echo >&2

REDO=${REDO:-0} # default: skip if exists. REDO !=0 means overwrite

usage(){
   [ $# -gt 0 ] && echo "$*"
  cat <<HERE
USAGE:
  $0 'path/file/to/check' cmd

  $0 sub-1/mri/aseg.nii.gz recon-all -s sub-1
  $0 sub-1/mri/aseg.nii.gz dryrun recon-all -s sub-1

SYNOPSIS:
  'test -s' wrapper with REDO and verbose messaging support

ENVIRONMENT:
   REDO=1  - overwrite (redo) even if output file exists

NOTES:
  Watch out for redirection. DONT DO THIS
     $0 /tmp/date.txt date > /tmp/date.txt # BAD BAD BAD

  Instead, use an exported function

     writedate() { date > \$1; }; export -f writedate
     $0 /tmp/date.txt writedate /tmp/date.txt

  or a dedicated shell

     $0 /tmp/date.txt sh -c 'date > /tmp/date.txt'
  
  But maybe '$0' is overkill for your usage. Consider:

     test -s /tmp/date.txt || date > \$_


ALSO SEE:
  dryrun drytee
HERE
}

[[ $# -eq 0 || "${1:-}" =~ ^-+h(help)?$ ]] && usage && exit 0

outfile="${1:?need two args. first is outfile}"; shift

[ $# -eq 0 ] &&
   usage "ERROR: no command to run if '$outfile' doesn't exist" >&2 &&
   exit 1

if [ -s "$outfile" ]; then
   [ "$REDO" == 0 ] &&
      echo "# SKIP: Already have '$outfile', not running '$*'; set REDO=1 to overwrite." >&2 &&
      exit 0
   echo " # Already have '$outfile' but overwritting: REDO=$REDO." >&2
fi
"$@"
